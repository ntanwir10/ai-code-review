import * as fs from 'fs';
import * as path from 'path';
import { marked } from 'marked';
import { LOCResult } from '../core/loc-counter';
import { RepositoryInfo } from '../core/repository';

export interface ReviewResult {
  summary: string;
  findings: Finding[];
  recommendations: string[];
  metadata: ReviewMetadata;
}

export interface Finding {
  severity: 'critical' | 'high' | 'medium' | 'low' | 'info';
  category: string;
  file: string;
  line?: number;
  description: string;
  suggestion?: string;
}

export interface ReviewMetadata {
  timestamp: string;
  repoInfo: RepositoryInfo;
  locStats: LOCResult;
  provider: string;
  model: string;
  durationMs: number;
}

export class Reporter {
  /**
   * Generate Markdown report
   */
  generateMarkdown(result: ReviewResult): string {
    const { summary, findings, recommendations, metadata } = result;

    let markdown = '# AI Code Review Report\n\n';

    // Metadata
    markdown += '## Overview\n\n';
    markdown += `- **Repository:** ${metadata.repoInfo.name}\n`;
    if (metadata.repoInfo.branch) {
      markdown += `- **Branch:** ${metadata.repoInfo.branch}\n`;
    }
    markdown += `- **Timestamp:** ${new Date(metadata.timestamp).toLocaleString()}\n`;
    markdown += `- **AI Provider:** ${metadata.provider}\n`;
    markdown += `- **Model:** ${metadata.model}\n`;
    markdown += `- **Duration:** ${(metadata.durationMs / 1000).toFixed(2)}s\n\n`;

    // LOC Stats
    markdown += '## Code Statistics\n\n';
    markdown += `- **Total Lines:** ${metadata.locStats.totalLines.toLocaleString()}\n`;
    markdown += `- **Code Lines:** ${metadata.locStats.codeLines.toLocaleString()}\n`;
    markdown += `- **Comment Lines:** ${metadata.locStats.commentLines.toLocaleString()}\n`;
    markdown += `- **Blank Lines:** ${metadata.locStats.blankLines.toLocaleString()}\n`;
    markdown += `- **Files Analyzed:** ${metadata.locStats.fileCount}\n\n`;

    // Summary
    markdown += '## Summary\n\n';
    markdown += summary + '\n\n';

    // Findings
    if (findings.length > 0) {
      markdown += '## Findings\n\n';

      const groupedFindings = this.groupFindingsBySeverity(findings);

      for (const severity of ['critical', 'high', 'medium', 'low', 'info'] as const) {
        const items = groupedFindings[severity];
        if (items.length === 0) continue;

        const icon = this.getSeverityIcon(severity);
        markdown += `### ${icon} ${severity.toUpperCase()} (${items.length})\n\n`;

        for (const finding of items) {
          markdown += `#### ${finding.category}\n\n`;
          markdown += `**File:** \`${finding.file}\``;
          if (finding.line) {
            markdown += ` (Line ${finding.line})`;
          }
          markdown += '\n\n';
          markdown += `${finding.description}\n\n`;
          if (finding.suggestion) {
            markdown += `**Suggestion:** ${finding.suggestion}\n\n`;
          }
        }
      }
    } else {
      markdown += '## Findings\n\n';
      markdown += 'âœ… No issues found!\n\n';
    }

    // Recommendations
    if (recommendations.length > 0) {
      markdown += '## Recommendations\n\n';
      for (const rec of recommendations) {
        markdown += `- ${rec}\n`;
      }
      markdown += '\n';
    }

    // Footer
    markdown += '---\n\n';
    markdown += '*Generated by AI Code Review CLI*\n';

    return markdown;
  }

  /**
   * Generate HTML report from markdown
   */
  async generateHTML(result: ReviewResult): Promise<string> {
    const markdown = this.generateMarkdown(result);
    const htmlContent = await marked(markdown);

    const html = `
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI Code Review Report</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      line-height: 1.6;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f5f5f5;
    }
    .container {
      background: white;
      padding: 40px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    h1 { color: #2c3e50; border-bottom: 3px solid #3498db; padding-bottom: 10px; }
    h2 { color: #34495e; margin-top: 30px; }
    h3 { color: #7f8c8d; }
    code { background: #ecf0f1; padding: 2px 6px; border-radius: 3px; font-family: 'Courier New', monospace; }
    pre { background: #2c3e50; color: #ecf0f1; padding: 15px; border-radius: 5px; overflow-x: auto; }
    .critical { color: #e74c3c; }
    .high { color: #e67e22; }
    .medium { color: #f39c12; }
    .low { color: #3498db; }
    .info { color: #95a5a6; }
    ul { padding-left: 20px; }
    li { margin: 5px 0; }
  </style>
</head>
<body>
  <div class="container">
    ${htmlContent}
  </div>
</body>
</html>
    `.trim();

    return html;
  }

  /**
   * Save report to file
   */
  saveReport(result: ReviewResult, format: 'markdown' | 'html' = 'markdown', outputPath?: string): string {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const defaultFilename = `code-review-${timestamp}.${format === 'markdown' ? 'md' : 'html'}`;
    const filepath = outputPath || path.join(process.cwd(), defaultFilename);

    let content: string;
    if (format === 'markdown') {
      content = this.generateMarkdown(result);
    } else {
      content = this.generateHTML(result) as any; // Will be resolved
    }

    fs.writeFileSync(filepath, content, 'utf-8');
    return filepath;
  }

  /**
   * Group findings by severity
   */
  private groupFindingsBySeverity(findings: Finding[]): Record<Finding['severity'], Finding[]> {
    return {
      critical: findings.filter(f => f.severity === 'critical'),
      high: findings.filter(f => f.severity === 'high'),
      medium: findings.filter(f => f.severity === 'medium'),
      low: findings.filter(f => f.severity === 'low'),
      info: findings.filter(f => f.severity === 'info'),
    };
  }

  /**
   * Get severity icon
   */
  private getSeverityIcon(severity: Finding['severity']): string {
    const icons = {
      critical: 'ðŸ”´',
      high: 'ðŸŸ ',
      medium: 'ðŸŸ¡',
      low: 'ðŸ”µ',
      info: 'âšª',
    };
    return icons[severity];
  }
}

export const reporter = new Reporter();
