import * as fs from 'fs';
import * as path from 'path';
import { marked } from 'marked';
import { LOCResult } from '../core/loc-counter';
import { RepositoryInfo } from '../core/repository';
import { chartGenerator, SeveritySummary, ComplexityData } from './chart-generator';

export interface ReviewResult {
  summary: string;
  findings: Finding[];
  recommendations: string[];
  metadata: ReviewMetadata;
}

export interface Finding {
  severity: 'critical' | 'high' | 'medium' | 'low' | 'info';
  category: string;
  file: string;
  line?: number;
  description: string;
  suggestion?: string;
}

export interface ReviewMetadata {
  timestamp: string;
  repoInfo: RepositoryInfo;
  locStats: LOCResult;
  provider: string;
  model: string;
  durationMs: number;
}

export class Reporter {
  /**
   * Generate Markdown report
   */
  generateMarkdown(result: ReviewResult): string {
    const { summary, findings, recommendations, metadata } = result;

    let markdown = '# GuardScan Report\n\n';

    // Metadata
    markdown += '## Overview\n\n';
    markdown += `- **Repository:** ${metadata.repoInfo.name}\n`;
    if (metadata.repoInfo.branch) {
      markdown += `- **Branch:** ${metadata.repoInfo.branch}\n`;
    }
    markdown += `- **Timestamp:** ${new Date(metadata.timestamp).toLocaleString()}\n`;
    markdown += `- **AI Provider:** ${metadata.provider}\n`;
    markdown += `- **Model:** ${metadata.model}\n`;
    markdown += `- **Duration:** ${(metadata.durationMs / 1000).toFixed(2)}s\n\n`;

    // LOC Stats
    markdown += '## Code Statistics\n\n';
    markdown += `- **Total Lines:** ${metadata.locStats.totalLines.toLocaleString()}\n`;
    markdown += `- **Code Lines:** ${metadata.locStats.codeLines.toLocaleString()}\n`;
    markdown += `- **Comment Lines:** ${metadata.locStats.commentLines.toLocaleString()}\n`;
    markdown += `- **Blank Lines:** ${metadata.locStats.blankLines.toLocaleString()}\n`;
    markdown += `- **Files Analyzed:** ${metadata.locStats.fileCount}\n\n`;

    // Summary
    markdown += '## Summary\n\n';
    markdown += summary + '\n\n';

    // Findings
    if (findings.length > 0) {
      markdown += '## Findings\n\n';

      const groupedFindings = this.groupFindingsBySeverity(findings);

      for (const severity of ['critical', 'high', 'medium', 'low', 'info'] as const) {
        const items = groupedFindings[severity];
        if (items.length === 0) continue;

        const icon = this.getSeverityIcon(severity);
        markdown += `### ${icon} ${severity.toUpperCase()} (${items.length})\n\n`;

        for (const finding of items) {
          markdown += `#### ${finding.category}\n\n`;
          markdown += `**File:** \`${finding.file}\``;
          if (finding.line) {
            markdown += ` (Line ${finding.line})`;
          }
          markdown += '\n\n';
          markdown += `${finding.description}\n\n`;
          if (finding.suggestion) {
            markdown += `**Suggestion:** ${finding.suggestion}\n\n`;
          }
        }
      }
    } else {
      markdown += '## Findings\n\n';
      markdown += 'âœ… No issues found!\n\n';
    }

    // Recommendations
    if (recommendations.length > 0) {
      markdown += '## Recommendations\n\n';
      for (const rec of recommendations) {
        markdown += `- ${rec}\n`;
      }
      markdown += '\n';
    }

    // Footer
    markdown += '---\n\n';
    markdown += '*Generated by GuardScan CLI*\n';

    return markdown;
  }

  /**
   * Generate HTML report from markdown with charts
   */
  async generateHTML(result: ReviewResult, outputDir?: string): Promise<string> {
    const markdown = this.generateMarkdown(result);
    const htmlContent = await marked(markdown);

    // Create images directory if generating charts
    const reportsDir = outputDir || path.join(process.cwd(), '.guardscan', 'reports');
    const imagesDir = path.join(reportsDir, 'images');

    if (!fs.existsSync(imagesDir)) {
      fs.mkdirSync(imagesDir, { recursive: true });
    }

    // Generate charts
    const chartImages: { [key: string]: string } = {};

    try {
      // Calculate severity summary
      const severitySummary = this.calculateSeveritySummary(result.findings);

      // Only generate chart if there are findings
      if (result.findings.length > 0) {
        const severityChart = await chartGenerator.generateSeverityChart(severitySummary);
        const severityChartPath = path.join(imagesDir, 'severity-distribution.png');
        fs.writeFileSync(severityChartPath, severityChart);
        chartImages.severity = 'images/severity-distribution.png';
      }

      // Generate category distribution chart if there are findings
      if (result.findings.length > 0) {
        const categoryData = this.calculateCategoryDistribution(result.findings);
        if (Object.keys(categoryData).length > 0) {
          const categoryChart = await chartGenerator.generateCategoryChart(categoryData);
          const categoryChartPath = path.join(imagesDir, 'category-distribution.png');
          fs.writeFileSync(categoryChartPath, categoryChart);
          chartImages.category = 'images/category-distribution.png';
        }
      }
    } catch (error) {
      // Chart generation failed, continue without charts
      console.error('Failed to generate charts:', error);
    }

    // Generate visual summary section
    let visualsSection = '';
    if (Object.keys(chartImages).length > 0) {
      visualsSection = `
      <section class="visuals">
        <h2>ðŸ“Š Visual Analysis</h2>
        <div class="charts-grid">
          ${chartImages.severity ? `
          <div class="chart-container">
            <h3>Severity Distribution</h3>
            <img src="${chartImages.severity}" alt="Severity Distribution" class="chart-image" />
          </div>
          ` : ''}
          ${chartImages.category ? `
          <div class="chart-container">
            <h3>Issues by Category</h3>
            <img src="${chartImages.category}" alt="Category Distribution" class="chart-image" />
          </div>
          ` : ''}
        </div>
      </section>
      `;
    }

    const html = `
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Code Review Report</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      line-height: 1.6;
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f5f5f5;
    }
    .container {
      background: white;
      padding: 40px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    h1 { color: #2c3e50; border-bottom: 3px solid #3498db; padding-bottom: 10px; }
    h2 { color: #34495e; margin-top: 30px; border-bottom: 2px solid #ecf0f1; padding-bottom: 8px; }
    h3 { color: #7f8c8d; }
    code { background: #ecf0f1; padding: 2px 6px; border-radius: 3px; font-family: 'Courier New', monospace; }
    pre { background: #2c3e50; color: #ecf0f1; padding: 15px; border-radius: 5px; overflow-x: auto; }
    .critical { color: #e74c3c; }
    .high { color: #e67e22; }
    .medium { color: #f39c12; }
    .low { color: #3498db; }
    .info { color: #95a5a6; }
    ul { padding-left: 20px; }
    li { margin: 5px 0; }
    .visuals { margin-top: 40px; }
    .charts-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
      gap: 30px;
      margin-top: 20px;
    }
    .chart-container {
      background: #f8f9fa;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    .chart-image {
      width: 100%;
      height: auto;
      border-radius: 4px;
    }
    .upgrade-notice {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 20px 30px;
      border-radius: 8px;
      margin-top: 40px;
      text-align: center;
    }
    .upgrade-notice h3 {
      margin-top: 0;
      color: white;
    }
    .upgrade-notice p {
      margin: 10px 0;
      opacity: 0.95;
    }
    .upgrade-notice a {
      color: #ffd700;
      text-decoration: none;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div class="container">
    ${htmlContent}
    ${visualsSection}
    ${result.metadata.provider === 'static-analysis' ? `
    <div class="upgrade-notice">
      <h3>ðŸ’¡ Want More Insights?</h3>
      <p>Upgrade to Pro for:</p>
      <ul style="list-style: none; padding: 0;">
        <li>ðŸ¤– AI-powered code analysis</li>
        <li>ðŸŽ¯ Context-aware understanding</li>
        <li>ðŸ“‹ PRD alignment checking</li>
        <li>ðŸ“Š Interactive dashboards</li>
      </ul>
      <p style="margin-top: 15px;">Configure with <code style="background: rgba(255,255,255,0.2); padding: 4px 8px; border-radius: 4px;">guardscan config</code></p>
    </div>
    ` : ''}
  </div>
</body>
</html>
    `.trim();

    return html;
  }

  /**
   * Save report to file
   */
  saveReport(result: ReviewResult, format: 'markdown' | 'html' = 'markdown', outputPath?: string): string {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const defaultFilename = `code-review-${timestamp}.${format === 'markdown' ? 'md' : 'html'}`;
    const filepath = outputPath || path.join(process.cwd(), defaultFilename);

    let content: string;
    if (format === 'markdown') {
      content = this.generateMarkdown(result);
    } else {
      content = this.generateHTML(result) as any; // Will be resolved
    }

    fs.writeFileSync(filepath, content, 'utf-8');
    return filepath;
  }

  /**
   * Group findings by severity
   */
  private groupFindingsBySeverity(findings: Finding[]): Record<Finding['severity'], Finding[]> {
    return {
      critical: findings.filter(f => f.severity === 'critical'),
      high: findings.filter(f => f.severity === 'high'),
      medium: findings.filter(f => f.severity === 'medium'),
      low: findings.filter(f => f.severity === 'low'),
      info: findings.filter(f => f.severity === 'info'),
    };
  }

  /**
   * Get severity icon
   */
  private getSeverityIcon(severity: Finding['severity']): string {
    const icons = {
      critical: 'ðŸ”´',
      high: 'ðŸŸ ',
      medium: 'ðŸŸ¡',
      low: 'ðŸ”µ',
      info: 'âšª',
    };
    return icons[severity];
  }

  /**
   * Calculate severity summary for charts
   */
  private calculateSeveritySummary(findings: Finding[]): SeveritySummary {
    return {
      critical: findings.filter(f => f.severity === 'critical').length,
      high: findings.filter(f => f.severity === 'high').length,
      medium: findings.filter(f => f.severity === 'medium').length,
      low: findings.filter(f => f.severity === 'low').length,
      info: findings.filter(f => f.severity === 'info').length,
    };
  }

  /**
   * Calculate category distribution for charts
   */
  private calculateCategoryDistribution(findings: Finding[]): { [key: string]: number } {
    const distribution: { [key: string]: number } = {};

    for (const finding of findings) {
      const category = finding.category;
      distribution[category] = (distribution[category] || 0) + 1;
    }

    return distribution;
  }
}

export const reporter = new Reporter();
