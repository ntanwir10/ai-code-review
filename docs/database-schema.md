# Database Schema

This document describes the Supabase/PostgreSQL database schema for GuardScan.

## Tables

### clients

Stores client information and usage tracking.

```sql
CREATE TABLE clients (
  client_id UUID PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  total_loc_used INTEGER NOT NULL DEFAULT 0,
  plan_tier VARCHAR(50) NOT NULL DEFAULT 'free',
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_clients_client_id ON clients(client_id);
```

**Columns:**
- `client_id` (UUID): Unique identifier generated by CLI
- `created_at` (TIMESTAMPTZ): When the client was first created
- `total_loc_used` (INTEGER): Total lines of code reviewed
- `plan_tier` (VARCHAR): Pricing tier (free, tier_1, tier_2, tier_3)
- `updated_at` (TIMESTAMPTZ): Last update timestamp

### repos

Stores anonymized repository information.

```sql
CREATE TABLE repos (
  repo_id VARCHAR(16) PRIMARY KEY,
  client_id UUID NOT NULL REFERENCES clients(client_id) ON DELETE CASCADE,
  loc_reviewed INTEGER NOT NULL DEFAULT 0,
  last_review_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_repos_client_id ON repos(client_id);
CREATE INDEX idx_repos_repo_id ON repos(repo_id);
```

**Columns:**
- `repo_id` (VARCHAR): Hashed repository identifier
- `client_id` (UUID): Reference to client
- `loc_reviewed` (INTEGER): Total LOC reviewed for this repo
- `last_review_at` (TIMESTAMPTZ): Last review timestamp
- `created_at` (TIMESTAMPTZ): When repo was first analyzed
- `updated_at` (TIMESTAMPTZ): Last update timestamp

### transactions

Stores credit purchase transactions.

```sql
CREATE TABLE transactions (
  transaction_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  client_id UUID NOT NULL REFERENCES clients(client_id) ON DELETE CASCADE,
  loc_purchased INTEGER NOT NULL,
  amount_usd DECIMAL(10, 2) NOT NULL,
  payment_status VARCHAR(50) NOT NULL,
  stripe_session_id VARCHAR(255),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_transactions_client_id ON transactions(client_id);
CREATE INDEX idx_transactions_payment_status ON transactions(payment_status);
CREATE INDEX idx_transactions_created_at ON transactions(created_at DESC);
```

**Columns:**
- `transaction_id` (UUID): Unique transaction identifier
- `client_id` (UUID): Reference to client
- `loc_purchased` (INTEGER): Number of LOC credits purchased
- `amount_usd` (DECIMAL): Purchase amount in USD
- `payment_status` (VARCHAR): Status (pending, paid, failed, refunded)
- `stripe_session_id` (VARCHAR): Stripe checkout session ID
- `created_at` (TIMESTAMPTZ): Transaction timestamp

### telemetry

Stores anonymized usage telemetry.

```sql
CREATE TABLE telemetry (
  event_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  client_id UUID NOT NULL REFERENCES clients(client_id) ON DELETE CASCADE,
  repo_id VARCHAR(16),
  action_type VARCHAR(50) NOT NULL,
  duration_ms INTEGER,
  model VARCHAR(100),
  loc INTEGER,
  timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_telemetry_client_id ON telemetry(client_id);
CREATE INDEX idx_telemetry_action_type ON telemetry(action_type);
CREATE INDEX idx_telemetry_timestamp ON telemetry(timestamp DESC);
```

**Columns:**
- `event_id` (UUID): Unique event identifier
- `client_id` (UUID): Reference to client
- `repo_id` (VARCHAR): Hashed repository identifier (nullable)
- `action_type` (VARCHAR): Action performed (review, security, config, etc.)
- `duration_ms` (INTEGER): Operation duration in milliseconds
- `model` (VARCHAR): AI model used (if applicable)
- `loc` (INTEGER): Lines of code processed
- `timestamp` (TIMESTAMPTZ): Event timestamp

## Setup Instructions

### 1. Create Supabase Project

1. Go to [supabase.com](https://supabase.com)
2. Create a new project
3. Note your project URL and API key

### 2. Run Schema Setup

Execute the following SQL in the Supabase SQL editor:

```sql
-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Create tables (use the CREATE TABLE statements above)

-- Create updated_at trigger function
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add triggers for updated_at
CREATE TRIGGER update_clients_updated_at
  BEFORE UPDATE ON clients
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_repos_updated_at
  BEFORE UPDATE ON repos
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();
```

### 3. Configure Row Level Security (RLS)

For production, enable RLS policies:

```sql
-- Enable RLS
ALTER TABLE clients ENABLE ROW LEVEL SECURITY;
ALTER TABLE repos ENABLE ROW LEVEL SECURITY;
ALTER TABLE transactions ENABLE ROW LEVEL SECURITY;
ALTER TABLE telemetry ENABLE ROW LEVEL SECURITY;

-- Create policies (adjust based on your auth requirements)
-- Example: Allow service role full access
CREATE POLICY "Service role has full access" ON clients
  FOR ALL USING (auth.role() = 'service_role');

CREATE POLICY "Service role has full access" ON repos
  FOR ALL USING (auth.role() = 'service_role');

CREATE POLICY "Service role has full access" ON transactions
  FOR ALL USING (auth.role() = 'service_role');

CREATE POLICY "Service role has full access" ON telemetry
  FOR ALL USING (auth.role() = 'service_role');
```

## Pricing Tiers

The pricing tiers are calculated based on LOC purchased:

- **tier_1**: 500–999 LOC → $0.010/LOC
- **tier_2**: 1000–4999 LOC → $0.009/LOC
- **tier_3**: 5000+ LOC → $0.008/LOC

Tier is determined automatically in Stripe checkout based on quantity selected.

## Data Privacy

- No source code is ever stored
- Repository IDs are cryptographically hashed
- Client IDs are UUIDs with no PII
- All data is anonymized and aggregated for analytics
